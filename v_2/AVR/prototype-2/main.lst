   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	TIM1_Init
  12               	TIM1_Init:
  13               	.LFB0:
  14               		.file 1 "main.c"
   1:main.c        **** // device: 	AtMega 32
   2:main.c        **** // author:  Maciej Mielcarski
   3:main.c        **** // Midi v2
   4:main.c        **** 
   5:main.c        **** #define F_CPU 16000000UL
   6:main.c        **** #include <avr/io.h>
   7:main.c        **** #include <avr/interrupt.h>
   8:main.c        **** //#define BAUD 9600 
   9:main.c        **** #define BAUD 31250
  10:main.c        **** #define MYUBRR F_CPU/16/BAUD-1	// ubrr = 31(MIDI) 113(9600) normal asynch. mode
  11:main.c        **** #include <util/setbaud.h>
  12:main.c        **** #define TIM1_PSC 1024		// TIMER 1 prescaler value
  13:main.c        **** #define TIM1_PER 10		// TIMER 1 desired period in miliseconds
  14:main.c        **** 
  15:main.c        **** #define NOTE_ON_CMD 0x90
  16:main.c        **** #define NOTE_OFF_CMD 0x80
  17:main.c        **** #define CC_CMD 0xB0
  18:main.c        **** #define PITCH_BEND_CMD 0xE0
  19:main.c        **** 
  20:main.c        **** #define VEL_DEF_CMD		0x40	// default 64 velocity
  21:main.c        **** 
  22:main.c        **** #define CC_VOLUME 0x07	// main volume control (0-127)
  23:main.c        **** 
  24:main.c        **** #define note1 PD0 
  25:main.c        **** #define note2 PD2 
  26:main.c        **** #define note3 PD3 
  27:main.c        **** #define note4 PD4 
  28:main.c        **** #define note5 PD5 
  29:main.c        **** #define note6 PD6 
  30:main.c        **** #define note7 PD7 
  31:main.c        **** #define note8 PC2 
  32:main.c        **** #define note9 PC3 
  33:main.c        **** #define note10 PC4 
  34:main.c        **** #define note11 PC5 
  35:main.c        **** #define note12 PC6 
  36:main.c        **** #define note13 PC7 
  37:main.c        **** 
  38:main.c        **** #define octave1 PB4 
  39:main.c        **** #define octave2 PB5 
  40:main.c        **** #define octave3 PB6 
  41:main.c        **** #define octave4 PB7 
  42:main.c        **** 
  43:main.c        ****  int NOTES_tab[13] = {note1,note2,note3,note4,note5,note6,note7,note8,note9,note10,note11,note12,no
  44:main.c        ****  int OCTAVES_tab[4] = {octave1,octave2,octave3,octave4};
  45:main.c        ****  int PRESSED_BUTTON_tab[13][4]={0};
  46:main.c        **** 
  47:main.c        ****  int adc_read[8] = {};
  48:main.c        ****  int adc_prev_read[8] = {};
  49:main.c        **** 
  50:main.c        ****  int adc_0 = 0, adc_1=0, adc_6=0;
  51:main.c        ****  int adc_0_prev = 0;
  52:main.c        **** int pitch_bend = 0;
  53:main.c        **** 
  54:main.c        **** //double control_value = 0;
  55:main.c        **** //double control_prev_value = 0;
  56:main.c        **** 
  57:main.c        **** // ------------------------- TIMER ----------------------------------------
  58:main.c        **** void TIM1_Init(void)	// enable interrupts
  59:main.c        **** {
  15               		.loc 1 59 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  60:main.c        ****     OCR1A = (((F_CPU/1000) / TIM1_PSC) * TIM1_PER) - 1;	// counter size
  21               		.loc 1 60 0
  22 0000 85E9      		ldi r24,lo8(-107)
  23 0002 90E0      		ldi r25,0
  24 0004 9BBD      		out 0x2a+1,r25
  25 0006 8ABD      		out 0x2a,r24
  61:main.c        ****     TCCR1B |= (1 << WGM12);							// Mode 4, CTC on OCR1A
  26               		.loc 1 61 0
  27 0008 8EB5      		in r24,0x2e
  28 000a 8860      		ori r24,lo8(8)
  29 000c 8EBD      		out 0x2e,r24
  62:main.c        ****     TIMSK |= (1 << OCIE1A);						// Set interrupt on compare match	
  30               		.loc 1 62 0
  31 000e 89B7      		in r24,0x39
  32 0010 8061      		ori r24,lo8(16)
  33 0012 89BF      		out 0x39,r24
  63:main.c        ****     TCCR1B |= (1 << CS12) | (1 << CS10);			// set prescaler to 1024 and start the timer
  34               		.loc 1 63 0
  35 0014 8EB5      		in r24,0x2e
  36 0016 8560      		ori r24,lo8(5)
  37 0018 8EBD      		out 0x2e,r24
  64:main.c        ****     sei();	
  38               		.loc 1 64 0
  39               	/* #APP */
  40               	 ;  64 "main.c" 1
  41 001a 7894      		sei
  42               	 ;  0 "" 2
  43               	/* #NOAPP */
  44 001c 0895      		ret
  45               		.cfi_endproc
  46               	.LFE0:
  48               	.global	USART_Init
  50               	USART_Init:
  51               	.LFB1:
  65:main.c        **** }
  66:main.c        **** 
  67:main.c        **** // ------------------------- USART ----------------------------------------
  68:main.c        **** void USART_Init(unsigned int ubrr)		
  69:main.c        **** {
  52               		.loc 1 69 0
  53               		.cfi_startproc
  54               	.LVL0:
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 0 */
  58               	.L__stack_usage = 0
  70:main.c        ****    UBRRH = (unsigned char)(ubrr>>8);	// set baud rate to 31250
  59               		.loc 1 70 0
  60 001e 90BD      		out 0x20,r25
  71:main.c        ****    UBRRL = (unsigned char)ubrr;		//
  61               		.loc 1 71 0
  62 0020 89B9      		out 0x9,r24
  72:main.c        ****    UCSRB = (1<<TXEN);		// Enable transmitter 
  63               		.loc 1 72 0
  64 0022 88E0      		ldi r24,lo8(8)
  65               	.LVL1:
  66 0024 8AB9      		out 0xa,r24
  73:main.c        ****    UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);		// Set frame format: 8data, 2stop bit
  67               		.loc 1 73 0
  68 0026 8EE8      		ldi r24,lo8(-114)
  69 0028 80BD      		out 0x20,r24
  70 002a 0895      		ret
  71               		.cfi_endproc
  72               	.LFE1:
  74               	.global	uart_putchar
  76               	uart_putchar:
  77               	.LFB2:
  74:main.c        **** }
  75:main.c        **** 
  76:main.c        **** void uart_putchar(char c) 
  77:main.c        **** {
  78               		.loc 1 77 0
  79               		.cfi_startproc
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 0 */
  83               	.L__stack_usage = 0
  84               	.LVL2:
  85               	.L4:
  78:main.c        **** 	while ( !(UCSRA & (1<<UDRE)) )	// Wait for empty transmit buffer 
  86               		.loc 1 78 0 discriminator 1
  87 002c 5D9B      		sbis 0xb,5
  88 002e 00C0      		rjmp .L4
  79:main.c        **** 	;
  80:main.c        ****     UDR = c;							// Put data into buffer, sends the data 
  89               		.loc 1 80 0
  90 0030 8CB9      		out 0xc,r24
  91 0032 0895      		ret
  92               		.cfi_endproc
  93               	.LFE2:
  95               	.global	uart_putstring
  97               	uart_putstring:
  98               	.LFB3:
  81:main.c        **** }
  82:main.c        **** 
  83:main.c        **** void uart_putstring(char tab[])
  84:main.c        **** {
  99               		.loc 1 84 0
 100               		.cfi_startproc
 101               	.LVL3:
 102 0034 CF93      		push r28
 103               	.LCFI0:
 104               		.cfi_def_cfa_offset 3
 105               		.cfi_offset 28, -2
 106 0036 DF93      		push r29
 107               	.LCFI1:
 108               		.cfi_def_cfa_offset 4
 109               		.cfi_offset 29, -3
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 2 */
 113               	.L__stack_usage = 2
 114               	.L9:
  85:main.c        **** 	int i =0;
  86:main.c        **** 	while (( UCSRA & (1<<UDRE))  == 0){};
 115               		.loc 1 86 0 discriminator 1
 116 0038 5D9B      		sbis 0xb,5
 117 003a 00C0      		rjmp .L9
 118 003c EC01      		movw r28,r24
 119               	.LVL4:
 120               	.L10:
  87:main.c        ****         while (tab[i] != 0x00)
 121               		.loc 1 87 0
 122 003e 8991      		ld r24,Y+
 123 0040 8823      		tst r24
 124 0042 01F0      		breq .L14
  88:main.c        **** 		{ 
  89:main.c        ****             uart_putchar(tab[i]);
 125               		.loc 1 89 0
 126 0044 0E94 0000 		call uart_putchar
 127               	.LVL5:
 128 0048 00C0      		rjmp .L10
 129               	.L14:
 130               	/* epilogue start */
  90:main.c        **** 			i++; 
  91:main.c        ****         }
  92:main.c        **** }
 131               		.loc 1 92 0
 132 004a DF91      		pop r29
 133 004c CF91      		pop r28
 134 004e 0895      		ret
 135               		.cfi_endproc
 136               	.LFE3:
 138               	.global	uart_putint
 140               	uart_putint:
 141               	.LFB4:
  93:main.c        **** 
  94:main.c        **** void uart_putint(int value)
  95:main.c        **** {
 142               		.loc 1 95 0
 143               		.cfi_startproc
 144               	.LVL6:
 145 0050 CF93      		push r28
 146               	.LCFI2:
 147               		.cfi_def_cfa_offset 3
 148               		.cfi_offset 28, -2
 149 0052 DF93      		push r29
 150               	.LCFI3:
 151               		.cfi_def_cfa_offset 4
 152               		.cfi_offset 29, -3
 153 0054 CDB7      		in r28,__SP_L__
 154 0056 DEB7      		in r29,__SP_H__
 155               	.LCFI4:
 156               		.cfi_def_cfa_register 28
 157 0058 6097      		sbiw r28,16
 158               	.LCFI5:
 159               		.cfi_def_cfa_offset 20
 160 005a 0FB6      		in __tmp_reg__,__SREG__
 161 005c F894      		cli
 162 005e DEBF      		out __SP_H__,r29
 163 0060 0FBE      		out __SREG__,__tmp_reg__
 164 0062 CDBF      		out __SP_L__,r28
 165               	/* prologue: function */
 166               	/* frame size = 16 */
 167               	/* stack size = 18 */
 168               	.L__stack_usage = 18
  96:main.c        **** 	char tab[16];
  97:main.c        **** 	itoa(value,tab,10);
 169               		.loc 1 97 0
 170 0064 4AE0      		ldi r20,lo8(10)
 171 0066 50E0      		ldi r21,0
 172 0068 BE01      		movw r22,r28
 173 006a 6F5F      		subi r22,-1
 174 006c 7F4F      		sbci r23,-1
 175 006e 0E94 0000 		call itoa
 176               	.LVL7:
  98:main.c        **** 	uart_putstring(tab);
 177               		.loc 1 98 0
 178 0072 CE01      		movw r24,r28
 179 0074 0196      		adiw r24,1
 180 0076 0E94 0000 		call uart_putstring
 181               	.LVL8:
 182               	/* epilogue start */
  99:main.c        **** }
 183               		.loc 1 99 0
 184 007a 6096      		adiw r28,16
 185 007c 0FB6      		in __tmp_reg__,__SREG__
 186 007e F894      		cli
 187 0080 DEBF      		out __SP_H__,r29
 188 0082 0FBE      		out __SREG__,__tmp_reg__
 189 0084 CDBF      		out __SP_L__,r28
 190 0086 DF91      		pop r29
 191 0088 CF91      		pop r28
 192 008a 0895      		ret
 193               		.cfi_endproc
 194               	.LFE4:
 196               	.global	ADC_Init
 198               	ADC_Init:
 199               	.LFB5:
 100:main.c        **** 
 101:main.c        **** // ------------------------- ADC ----------------------------------------
 102:main.c        **** void ADC_Init(void)
 103:main.c        **** {
 200               		.loc 1 103 0
 201               		.cfi_startproc
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 0 */
 205               	.L__stack_usage = 0
 104:main.c        **** 	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample 
 206               		.loc 1 104 0
 207 008c 86B1      		in r24,0x6
 208 008e 8760      		ori r24,lo8(7)
 209 0090 86B9      		out 0x6,r24
 105:main.c        **** 	ADMUX |= (1 << REFS0); 	// Set ADC reference to AVCC
 210               		.loc 1 105 0
 211 0092 3E9A      		sbi 0x7,6
 106:main.c        **** 	ADCSRA |= (1 << ADEN);  // Enable ADC
 212               		.loc 1 106 0
 213 0094 379A      		sbi 0x6,7
 214 0096 0895      		ret
 215               		.cfi_endproc
 216               	.LFE5:
 218               	.global	ADC_read
 220               	ADC_read:
 221               	.LFB6:
 107:main.c        **** }
 108:main.c        **** 
 109:main.c        **** uint16_t ADC_read(uint8_t channel)		
 110:main.c        **** {
 222               		.loc 1 110 0
 223               		.cfi_startproc
 224               	.LVL9:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 0 */
 228               	.L__stack_usage = 0
 111:main.c        **** 	channel &= 0x07;					// AND operation with 7 (will keep channel between 0-7) 
 112:main.c        **** 	ADMUX = (ADMUX & 0xF8) | channel;	// clears 3 first bits before OR
 229               		.loc 1 112 0
 230 0098 97B1      		in r25,0x7
 231 009a 987F      		andi r25,lo8(-8)
 232 009c 8770      		andi r24,lo8(7)
 233               	.LVL10:
 234 009e 892B      		or r24,r25
 235               	.LVL11:
 236 00a0 87B9      		out 0x7,r24
 113:main.c        **** 	ADCSRA |= (1 << ADSC);				// start single convesrion
 237               		.loc 1 113 0
 238 00a2 369A      		sbi 0x6,6
 239               	.L18:
 114:main.c        **** 	while(ADCSRA & (1 << ADSC));		// wait for conversion to complete
 240               		.loc 1 114 0 discriminator 1
 241 00a4 3699      		sbic 0x6,6
 242 00a6 00C0      		rjmp .L18
 115:main.c        **** 	return ADCW;
 243               		.loc 1 115 0
 244 00a8 84B1      		in r24,0x4
 245 00aa 95B1      		in r25,0x4+1
 116:main.c        **** }
 246               		.loc 1 116 0
 247 00ac 0895      		ret
 248               		.cfi_endproc
 249               	.LFE6:
 251               	.global	PORT_Init
 253               	PORT_Init:
 254               	.LFB7:
 117:main.c        **** // ------------------------- OTHER ----------------------------------------
 118:main.c        **** 
 119:main.c        **** void PORT_Init(void)
 120:main.c        **** {
 255               		.loc 1 120 0
 256               		.cfi_startproc
 257               	/* prologue: function */
 258               	/* frame size = 0 */
 259               	/* stack size = 0 */
 260               	.L__stack_usage = 0
 121:main.c        **** 	MCUCSR = (1<<JTD);			//disabling JTAG
 261               		.loc 1 121 0
 262 00ae 80E8      		ldi r24,lo8(-128)
 263 00b0 84BF      		out 0x34,r24
 122:main.c        **** 	MCUCSR = (1<<JTD);			//
 264               		.loc 1 122 0
 265 00b2 84BF      		out 0x34,r24
 123:main.c        **** 	DDRD = 0xFF;
 266               		.loc 1 123 0
 267 00b4 8FEF      		ldi r24,lo8(-1)
 268 00b6 81BB      		out 0x11,r24
 124:main.c        **** 	DDRC = 0xFF;
 269               		.loc 1 124 0
 270 00b8 84BB      		out 0x14,r24
 271 00ba 0895      		ret
 272               		.cfi_endproc
 273               	.LFE7:
 275               	.global	note_on
 277               	note_on:
 278               	.LFB8:
 125:main.c        **** }
 126:main.c        **** 
 127:main.c        **** void note_on(int key, int oct)
 128:main.c        **** {
 279               		.loc 1 128 0
 280               		.cfi_startproc
 281               	.LVL12:
 282 00bc CF93      		push r28
 283               	.LCFI6:
 284               		.cfi_def_cfa_offset 3
 285               		.cfi_offset 28, -2
 286 00be DF93      		push r29
 287               	.LCFI7:
 288               		.cfi_def_cfa_offset 4
 289               		.cfi_offset 29, -3
 290               	/* prologue: function */
 291               	/* frame size = 0 */
 292               	/* stack size = 2 */
 293               	.L__stack_usage = 2
 294 00c0 C82F      		mov r28,r24
 295 00c2 D62F      		mov r29,r22
 129:main.c        **** 	uart_putchar(NOTE_ON_CMD);		// note on
 296               		.loc 1 129 0
 297 00c4 80E9      		ldi r24,lo8(-112)
 298               	.LVL13:
 299 00c6 0E94 0000 		call uart_putchar
 300               	.LVL14:
 130:main.c        **** 	uart_putchar(key + oct * 12);
 301               		.loc 1 130 0
 302 00ca 8C2F      		mov r24,r28
 303 00cc 9CE0      		ldi r25,lo8(12)
 304 00ce D99F      		mul r29,r25
 305 00d0 800D      		add r24,r0
 306 00d2 1124      		clr __zero_reg__
 307 00d4 0E94 0000 		call uart_putchar
 308               	.LVL15:
 131:main.c        **** 	uart_putchar(VEL_DEF_CMD);
 309               		.loc 1 131 0
 310 00d8 80E4      		ldi r24,lo8(64)
 311               	/* epilogue start */
 132:main.c        **** }
 312               		.loc 1 132 0
 313 00da DF91      		pop r29
 314 00dc CF91      		pop r28
 131:main.c        **** 	uart_putchar(VEL_DEF_CMD);
 315               		.loc 1 131 0
 316 00de 0C94 0000 		jmp uart_putchar
 317               	.LVL16:
 318               		.cfi_endproc
 319               	.LFE8:
 321               	.global	note_off
 323               	note_off:
 324               	.LFB9:
 133:main.c        **** 
 134:main.c        **** void note_off(int key, int oct)
 135:main.c        **** {
 325               		.loc 1 135 0
 326               		.cfi_startproc
 327               	.LVL17:
 328 00e2 CF93      		push r28
 329               	.LCFI8:
 330               		.cfi_def_cfa_offset 3
 331               		.cfi_offset 28, -2
 332 00e4 DF93      		push r29
 333               	.LCFI9:
 334               		.cfi_def_cfa_offset 4
 335               		.cfi_offset 29, -3
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 2 */
 339               	.L__stack_usage = 2
 340 00e6 C82F      		mov r28,r24
 341 00e8 D62F      		mov r29,r22
 136:main.c        **** 	uart_putchar(NOTE_OFF_CMD);		// note off
 342               		.loc 1 136 0
 343 00ea 80E8      		ldi r24,lo8(-128)
 344               	.LVL18:
 345 00ec 0E94 0000 		call uart_putchar
 346               	.LVL19:
 137:main.c        **** 	uart_putchar(key + oct * 12);
 347               		.loc 1 137 0
 348 00f0 8C2F      		mov r24,r28
 349 00f2 9CE0      		ldi r25,lo8(12)
 350 00f4 D99F      		mul r29,r25
 351 00f6 800D      		add r24,r0
 352 00f8 1124      		clr __zero_reg__
 353 00fa 0E94 0000 		call uart_putchar
 354               	.LVL20:
 138:main.c        **** 	uart_putchar(VEL_DEF_CMD);
 355               		.loc 1 138 0
 356 00fe 80E4      		ldi r24,lo8(64)
 357               	/* epilogue start */
 139:main.c        **** }
 358               		.loc 1 139 0
 359 0100 DF91      		pop r29
 360 0102 CF91      		pop r28
 138:main.c        **** 	uart_putchar(VEL_DEF_CMD);
 361               		.loc 1 138 0
 362 0104 0C94 0000 		jmp uart_putchar
 363               	.LVL21:
 364               		.cfi_endproc
 365               	.LFE9:
 367               	.global	CC_send_ADC
 369               	CC_send_ADC:
 370               	.LFB10:
 140:main.c        **** 
 141:main.c        **** void CC_send_ADC(uint8_t control_num,  unsigned int channel)
 142:main.c        **** {
 371               		.loc 1 142 0
 372               		.cfi_startproc
 373               	.LVL22:
 374 0108 FF92      		push r15
 375               	.LCFI10:
 376               		.cfi_def_cfa_offset 3
 377               		.cfi_offset 15, -2
 378 010a 0F93      		push r16
 379               	.LCFI11:
 380               		.cfi_def_cfa_offset 4
 381               		.cfi_offset 16, -3
 382 010c 1F93      		push r17
 383               	.LCFI12:
 384               		.cfi_def_cfa_offset 5
 385               		.cfi_offset 17, -4
 386 010e CF93      		push r28
 387               	.LCFI13:
 388               		.cfi_def_cfa_offset 6
 389               		.cfi_offset 28, -5
 390 0110 DF93      		push r29
 391               	.LCFI14:
 392               		.cfi_def_cfa_offset 7
 393               		.cfi_offset 29, -6
 394               	/* prologue: function */
 395               	/* frame size = 0 */
 396               	/* stack size = 5 */
 397               	.L__stack_usage = 5
 398 0112 F82E      		mov r15,r24
 143:main.c        **** 	adc_prev_read[channel] = adc_read[channel];
 399               		.loc 1 143 0
 400 0114 EB01      		movw r28,r22
 401 0116 CC0F      		lsl r28
 402 0118 DD1F      		rol r29
 403               	.LVL23:
 404 011a 8E01      		movw r16,r28
 405 011c 0050      		subi r16,lo8(-(adc_prev_read))
 406 011e 1040      		sbci r17,hi8(-(adc_prev_read))
 407 0120 C050      		subi r28,lo8(-(adc_read))
 408 0122 D040      		sbci r29,hi8(-(adc_read))
 409 0124 8881      		ld r24,Y
 410 0126 9981      		ldd r25,Y+1
 411 0128 F801      		movw r30,r16
 412 012a 9183      		std Z+1,r25
 413 012c 8083      		st Z,r24
 144:main.c        **** 	adc_read[channel] = ADC_read(channel);
 414               		.loc 1 144 0
 415 012e 862F      		mov r24,r22
 416 0130 0E94 0000 		call ADC_read
 417               	.LVL24:
 418 0134 9983      		std Y+1,r25
 419 0136 8883      		st Y,r24
 145:main.c        **** 
 146:main.c        **** 	//value = value*127/1024;
 147:main.c        **** 	//prev_value = prev_value*127/1024;
 148:main.c        **** 
 149:main.c        **** 	uint8_t adc_7bit = (adc_read[channel] >> 3);
 420               		.loc 1 149 0
 421 0138 EC01      		movw r28,r24
 422 013a 93E0      		ldi r25,3
 423               		1:
 424 013c D595      		asr r29
 425 013e C795      		ror r28
 426 0140 9A95      		dec r25
 427 0142 01F4      		brne 1b
 428               	.LVL25:
 150:main.c        **** 	uint8_t adc_prev_7bit = (adc_prev_read[channel] >> 3);
 151:main.c        **** 
 152:main.c        **** 	//uart_putint(test1);
 153:main.c        **** 	//uart_putstring("\n");
 154:main.c        **** 
 155:main.c        **** 	if((int)adc_7bit != (int)adc_prev_7bit)
 429               		.loc 1 155 0
 430 0144 F801      		movw r30,r16
 431 0146 8081      		ld r24,Z
 432 0148 9181      		ldd r25,Z+1
 433 014a 23E0      		ldi r18,3
 434               		1:
 435 014c 9595      		asr r25
 436 014e 8795      		ror r24
 437 0150 2A95      		dec r18
 438 0152 01F4      		brne 1b
 439 0154 C817      		cp r28,r24
 440 0156 01F0      		breq .L23
 156:main.c        **** 	{
 157:main.c        **** 		uart_putchar(CC_CMD);
 441               		.loc 1 157 0
 442 0158 80EB      		ldi r24,lo8(-80)
 443 015a 0E94 0000 		call uart_putchar
 444               	.LVL26:
 158:main.c        **** 		uart_putchar(control_num);
 445               		.loc 1 158 0
 446 015e 8F2D      		mov r24,r15
 447 0160 0E94 0000 		call uart_putchar
 448               	.LVL27:
 159:main.c        **** 		uart_putchar(adc_7bit);
 449               		.loc 1 159 0
 450 0164 8C2F      		mov r24,r28
 451               	/* epilogue start */
 160:main.c        **** 	}
 161:main.c        **** }
 452               		.loc 1 161 0
 453 0166 DF91      		pop r29
 454 0168 CF91      		pop r28
 455               	.LVL28:
 456 016a 1F91      		pop r17
 457 016c 0F91      		pop r16
 458 016e FF90      		pop r15
 459               	.LVL29:
 159:main.c        **** 		uart_putchar(adc_7bit);
 460               		.loc 1 159 0
 461 0170 0C94 0000 		jmp uart_putchar
 462               	.LVL30:
 463               	.L23:
 464               	/* epilogue start */
 465               		.loc 1 161 0
 466 0174 DF91      		pop r29
 467 0176 CF91      		pop r28
 468               	.LVL31:
 469 0178 1F91      		pop r17
 470 017a 0F91      		pop r16
 471               	.LVL32:
 472 017c FF90      		pop r15
 473               	.LVL33:
 474 017e 0895      		ret
 475               		.cfi_endproc
 476               	.LFE10:
 478               	.global	__vector_7
 480               	__vector_7:
 481               	.LFB11:
 162:main.c        **** 
 163:main.c        **** ISR(TIMER1_COMPA_vect)	// timer1 overflow interrupt
 164:main.c        **** {
 482               		.loc 1 164 0
 483               		.cfi_startproc
 484 0180 1F92      		push r1
 485               	.LCFI15:
 486               		.cfi_def_cfa_offset 3
 487               		.cfi_offset 1, -2
 488 0182 0F92      		push r0
 489               	.LCFI16:
 490               		.cfi_def_cfa_offset 4
 491               		.cfi_offset 0, -3
 492 0184 0FB6      		in r0,__SREG__
 493 0186 0F92      		push r0
 494 0188 1124      		clr __zero_reg__
 495 018a 2F93      		push r18
 496               	.LCFI17:
 497               		.cfi_def_cfa_offset 5
 498               		.cfi_offset 18, -4
 499 018c 3F93      		push r19
 500               	.LCFI18:
 501               		.cfi_def_cfa_offset 6
 502               		.cfi_offset 19, -5
 503 018e 4F93      		push r20
 504               	.LCFI19:
 505               		.cfi_def_cfa_offset 7
 506               		.cfi_offset 20, -6
 507 0190 5F93      		push r21
 508               	.LCFI20:
 509               		.cfi_def_cfa_offset 8
 510               		.cfi_offset 21, -7
 511 0192 6F93      		push r22
 512               	.LCFI21:
 513               		.cfi_def_cfa_offset 9
 514               		.cfi_offset 22, -8
 515 0194 7F93      		push r23
 516               	.LCFI22:
 517               		.cfi_def_cfa_offset 10
 518               		.cfi_offset 23, -9
 519 0196 8F93      		push r24
 520               	.LCFI23:
 521               		.cfi_def_cfa_offset 11
 522               		.cfi_offset 24, -10
 523 0198 9F93      		push r25
 524               	.LCFI24:
 525               		.cfi_def_cfa_offset 12
 526               		.cfi_offset 25, -11
 527 019a AF93      		push r26
 528               	.LCFI25:
 529               		.cfi_def_cfa_offset 13
 530               		.cfi_offset 26, -12
 531 019c BF93      		push r27
 532               	.LCFI26:
 533               		.cfi_def_cfa_offset 14
 534               		.cfi_offset 27, -13
 535 019e EF93      		push r30
 536               	.LCFI27:
 537               		.cfi_def_cfa_offset 15
 538               		.cfi_offset 30, -14
 539 01a0 FF93      		push r31
 540               	.LCFI28:
 541               		.cfi_def_cfa_offset 16
 542               		.cfi_offset 31, -15
 543               	/* prologue: Signal */
 544               	/* frame size = 0 */
 545               	/* stack size = 15 */
 546               	.L__stack_usage = 15
 165:main.c        **** 		 //adc_0_prev = adc_0;
 166:main.c        **** 	 //adc_0 = ADC_read(0);
 167:main.c        **** 
 168:main.c        **** 	//if(adc_0 <= (adc_0_prev - 5) || adc_0 >= (adc_0_prev + 5))
 169:main.c        **** 	//{
 170:main.c        **** 		CC_send_ADC(CC_VOLUME, 0);	// slide 1
 547               		.loc 1 170 0
 548 01a2 60E0      		ldi r22,0
 549 01a4 70E0      		ldi r23,0
 550 01a6 87E0      		ldi r24,lo8(7)
 551 01a8 0E94 0000 		call CC_send_ADC
 552               	.LVL34:
 171:main.c        **** 		CC_send_ADC(CC_VOLUME, 4);	// knob 3
 553               		.loc 1 171 0
 554 01ac 64E0      		ldi r22,lo8(4)
 555 01ae 70E0      		ldi r23,0
 556 01b0 87E0      		ldi r24,lo8(7)
 557 01b2 0E94 0000 		call CC_send_ADC
 558               	.LVL35:
 172:main.c        **** 		CC_send_ADC(CC_VOLUME, 6);	// joystick 1
 559               		.loc 1 172 0
 560 01b6 66E0      		ldi r22,lo8(6)
 561 01b8 70E0      		ldi r23,0
 562 01ba 87E0      		ldi r24,lo8(7)
 563 01bc 0E94 0000 		call CC_send_ADC
 564               	.LVL36:
 173:main.c        **** 		CC_send_ADC(CC_VOLUME, 7);	// joystick 2
 565               		.loc 1 173 0
 566 01c0 67E0      		ldi r22,lo8(7)
 567 01c2 70E0      		ldi r23,0
 568 01c4 87E0      		ldi r24,lo8(7)
 569 01c6 0E94 0000 		call CC_send_ADC
 570               	.LVL37:
 571               	/* epilogue start */
 174:main.c        **** 	//}
 175:main.c        **** 	
 176:main.c        **** 	//uart_putchar(CC_CMD);
 177:main.c        **** 	//uart_putchar(CC_VOLUME);
 178:main.c        **** 	//uart_putchar(adc_0*127/1024);
 179:main.c        **** 	// uart_putchar(PITCH_BEND_CMD);
 180:main.c        **** 	// pitch_bend = 16384 / adc_6;
 181:main.c        **** 	// uart_putchar((unsigned char)(pitch_bend>>7));
 182:main.c        **** 	// uart_putchar((unsigned char)pitch_bend);
 183:main.c        **** 
 184:main.c        **** 	// ------- ADC test -------
 185:main.c        **** 
 186:main.c        **** 	// uart_putstring("\nADC0:");
 187:main.c        **** 	// uart_putint(adc_0);
 188:main.c        **** 	// //uart_putchar('K');
 189:main.c        **** 
 190:main.c        **** 	//adc_1 = ADC_read(1);
 191:main.c        **** 	//uart_putstring("\nADC1:");
 192:main.c        **** 	//uart_putint(adc_1);
 193:main.c        **** 
 194:main.c        **** 	//  adc_6 = ADC_read(6);
 195:main.c        **** 	//  uart_putstring("\nADC6:");
 196:main.c        **** 	//  uart_putint(adc_6);
 197:main.c        **** }
 572               		.loc 1 197 0
 573 01ca FF91      		pop r31
 574 01cc EF91      		pop r30
 575 01ce BF91      		pop r27
 576 01d0 AF91      		pop r26
 577 01d2 9F91      		pop r25
 578 01d4 8F91      		pop r24
 579 01d6 7F91      		pop r23
 580 01d8 6F91      		pop r22
 581 01da 5F91      		pop r21
 582 01dc 4F91      		pop r20
 583 01de 3F91      		pop r19
 584 01e0 2F91      		pop r18
 585 01e2 0F90      		pop r0
 586 01e4 0FBE      		out __SREG__,r0
 587 01e6 0F90      		pop r0
 588 01e8 1F90      		pop r1
 589 01ea 1895      		reti
 590               		.cfi_endproc
 591               	.LFE11:
 593               		.section	.text.startup,"ax",@progbits
 594               	.global	main
 596               	main:
 597               	.LFB12:
 198:main.c        **** 
 199:main.c        **** // ------------------------- MAIN ----------------------------------------
 200:main.c        **** 
 201:main.c        **** int main(void)
 202:main.c        **** {
 598               		.loc 1 202 0
 599               		.cfi_startproc
 600               	/* prologue: function */
 601               	/* frame size = 0 */
 602               	/* stack size = 0 */
 603               	.L__stack_usage = 0
 203:main.c        **** 	USART_Init(MYUBRR);
 604               		.loc 1 203 0
 605 0000 8FE1      		ldi r24,lo8(31)
 606 0002 90E0      		ldi r25,0
 607 0004 0E94 0000 		call USART_Init
 608               	.LVL38:
 204:main.c        **** 	PORT_Init();
 609               		.loc 1 204 0
 610 0008 0E94 0000 		call PORT_Init
 611               	.LVL39:
 205:main.c        **** 	ADC_Init();
 612               		.loc 1 205 0
 613 000c 0E94 0000 		call ADC_Init
 614               	.LVL40:
 206:main.c        **** 	TIM1_Init();
 615               		.loc 1 206 0
 616 0010 0E94 0000 		call TIM1_Init
 617               	.LVL41:
 618               	.LBB2:
 207:main.c        **** 
 208:main.c        **** 	while(1)
 209:main.c        **** 	{
 210:main.c        **** 		// ----- keyboard handle -> working without last key --------
 211:main.c        **** 
 212:main.c        **** 		for(int i=0; i<13; i++)		// notes loop
 213:main.c        **** 		{
 214:main.c        **** 			if(i < 7)	// PORTD
 215:main.c        **** 			{
 216:main.c        **** 				PORTD |= (1<<NOTES_tab[i]);
 217:main.c        **** 			}
 218:main.c        **** 			else		// PORTC
 219:main.c        **** 			{
 220:main.c        **** 				PORTC |= (1<<NOTES_tab[i]);
 619               		.loc 1 220 0
 620 0014 CC24      		clr r12
 621 0016 C394      		inc r12
 622 0018 D12C      		mov r13,__zero_reg__
 623               	.L35:
 624               	.LVL42:
 625 001a 00E0      		ldi r16,lo8(NOTES_tab)
 626 001c 10E0      		ldi r17,hi8(NOTES_tab)
 627 001e 90E0      		ldi r25,lo8(PRESSED_BUTTON_tab)
 628 0020 692E      		mov r6,r25
 629 0022 90E0      		ldi r25,hi8(PRESSED_BUTTON_tab)
 630 0024 792E      		mov r7,r25
 212:main.c        **** 		{
 631               		.loc 1 212 0
 632 0026 C0E0      		ldi r28,0
 633 0028 D0E0      		ldi r29,0
 634               	.LVL43:
 635               	.L34:
 214:main.c        **** 			{
 636               		.loc 1 214 0
 637 002a C730      		cpi r28,7
 638 002c D105      		cpc r29,__zero_reg__
 639 002e 04F4      		brge .L27
 216:main.c        **** 			}
 640               		.loc 1 216 0
 641 0030 22B3      		in r18,0x12
 642 0032 C601      		movw r24,r12
 643 0034 F801      		movw r30,r16
 644 0036 0080      		ld r0,Z
 645 0038 00C0      		rjmp 2f
 646               		1:
 647 003a 880F      		lsl r24
 648 003c 991F      		rol r25
 649               		2:
 650 003e 0A94      		dec r0
 651 0040 02F4      		brpl 1b
 652 0042 822B      		or r24,r18
 653 0044 82BB      		out 0x12,r24
 654 0046 00C0      		rjmp .L28
 655               	.L27:
 656               		.loc 1 220 0
 657 0048 25B3      		in r18,0x15
 658 004a C601      		movw r24,r12
 659 004c F801      		movw r30,r16
 660 004e 0080      		ld r0,Z
 661 0050 00C0      		rjmp 2f
 662               		1:
 663 0052 880F      		lsl r24
 664 0054 991F      		rol r25
 665               		2:
 666 0056 0A94      		dec r0
 667 0058 02F4      		brpl 1b
 668 005a 822B      		or r24,r18
 669 005c 85BB      		out 0x15,r24
 670               	.L28:
 671               	.LVL44:
 672 005e 80E0      		ldi r24,lo8(OCTAVES_tab)
 673 0060 A82E      		mov r10,r24
 674 0062 80E0      		ldi r24,hi8(OCTAVES_tab)
 675 0064 B82E      		mov r11,r24
 212:main.c        **** 		{
 676               		.loc 1 212 0 discriminator 1
 677 0066 7301      		movw r14,r6
 678 0068 812C      		mov r8,__zero_reg__
 679 006a 912C      		mov r9,__zero_reg__
 680               	.LVL45:
 681               	.L31:
 682               	.LBB3:
 221:main.c        **** 			}
 222:main.c        **** 
 223:main.c        **** 			// if(i == 12)		// last key case
 224:main.c        **** 			// {
 225:main.c        **** 			// 	if(PINC & (1<<NOTES_tab[12]) && !(PRESSED_BUTTON_tab[12][0]) )
 226:main.c        **** 			// 	{
 227:main.c        **** 			// 		PRESSED_BUTTON_tab[12][0] = 1;
 228:main.c        **** 			// 		note_on(12,0);
 229:main.c        **** 			// 	}
 230:main.c        **** 			// 	else if( !(PINC & (1<<NOTES_tab[12])) && PRESSED_BUTTON_tab[12][0])
 231:main.c        **** 			// 	{
 232:main.c        **** 			// 		PRESSED_BUTTON_tab[12][0] = 0;
 233:main.c        **** 			// 		note_off(12,0);
 234:main.c        **** 			// 	}
 235:main.c        **** 			// }
 236:main.c        **** 
 237:main.c        **** 			for(int j=0; j<4; j++)		// octaves loop
 238:main.c        **** 			{
 239:main.c        **** 				if( PINB & (1<<OCTAVES_tab[j]) && !(PRESSED_BUTTON_tab[i][j]) )
 683               		.loc 1 239 0
 684 006c 86B3      		in r24,0x16
 685 006e F501      		movw r30,r10
 686 0070 2081      		ld r18,Z
 687 0072 F2E0      		ldi r31,2
 688 0074 AF0E      		add r10,r31
 689 0076 B11C      		adc r11,__zero_reg__
 690 0078 90E0      		ldi r25,0
 691 007a 022E      		mov r0,r18
 692 007c 00C0      		rjmp 2f
 693               		1:
 694 007e 9595      		asr r25
 695 0080 8795      		ror r24
 696               		2:
 697 0082 0A94      		dec r0
 698 0084 02F4      		brpl 1b
 699 0086 80FF      		sbrs r24,0
 700 0088 00C0      		rjmp .L29
 701               		.loc 1 239 0 is_stmt 0 discriminator 1
 702 008a F701      		movw r30,r14
 703 008c 8081      		ld r24,Z
 704 008e 9181      		ldd r25,Z+1
 705 0090 892B      		or r24,r25
 706 0092 01F4      		brne .L29
 240:main.c        **** 				{
 241:main.c        **** 					PRESSED_BUTTON_tab[i][j] = 1;
 707               		.loc 1 241 0 is_stmt 1
 708 0094 D182      		std Z+1,r13
 709 0096 C082      		st Z,r12
 242:main.c        **** 					note_on(i,j);
 710               		.loc 1 242 0
 711 0098 B401      		movw r22,r8
 712 009a CE01      		movw r24,r28
 713 009c 0E94 0000 		call note_on
 714               	.LVL46:
 715 00a0 00C0      		rjmp .L30
 716               	.L29:
 243:main.c        **** 				}
 244:main.c        **** 				else if( !(PINB & (1<<OCTAVES_tab[j])) && PRESSED_BUTTON_tab[i][j] )
 717               		.loc 1 244 0
 718 00a2 86B3      		in r24,0x16
 719 00a4 90E0      		ldi r25,0
 720 00a6 00C0      		rjmp 2f
 721               		1:
 722 00a8 9595      		asr r25
 723 00aa 8795      		ror r24
 724               		2:
 725 00ac 2A95      		dec r18
 726 00ae 02F4      		brpl 1b
 727 00b0 80FD      		sbrc r24,0
 728 00b2 00C0      		rjmp .L30
 729               		.loc 1 244 0 is_stmt 0 discriminator 1
 730 00b4 F701      		movw r30,r14
 731 00b6 8081      		ld r24,Z
 732 00b8 9181      		ldd r25,Z+1
 733 00ba 892B      		or r24,r25
 734 00bc 01F0      		breq .L30
 245:main.c        **** 				{
 246:main.c        **** 					PRESSED_BUTTON_tab[i][j] = 0;
 735               		.loc 1 246 0 is_stmt 1
 736 00be 1182      		std Z+1,__zero_reg__
 737 00c0 1082      		st Z,__zero_reg__
 247:main.c        **** 					note_off(i,j);
 738               		.loc 1 247 0
 739 00c2 B401      		movw r22,r8
 740 00c4 CE01      		movw r24,r28
 741 00c6 0E94 0000 		call note_off
 742               	.LVL47:
 743               	.L30:
 237:main.c        **** 			{
 744               		.loc 1 237 0 discriminator 2
 745 00ca FFEF      		ldi r31,-1
 746 00cc 8F1A      		sub r8,r31
 747 00ce 9F0A      		sbc r9,r31
 748               	.LVL48:
 749 00d0 82E0      		ldi r24,2
 750 00d2 E80E      		add r14,r24
 751 00d4 F11C      		adc r15,__zero_reg__
 752 00d6 94E0      		ldi r25,4
 753 00d8 8916      		cp r8,r25
 754 00da 9104      		cpc r9,__zero_reg__
 755 00dc 01F4      		brne .L31
 756               	.LBE3:
 248:main.c        **** 				}
 249:main.c        **** 			}
 250:main.c        **** 			
 251:main.c        **** 			if(i < 7)	// PORTD
 757               		.loc 1 251 0
 758 00de C730      		cpi r28,7
 759 00e0 D105      		cpc r29,__zero_reg__
 760 00e2 04F4      		brge .L32
 252:main.c        **** 			{
 253:main.c        **** 				PORTD &= ~(1<<NOTES_tab[i]);
 761               		.loc 1 253 0
 762 00e4 92B3      		in r25,0x12
 763 00e6 9601      		movw r18,r12
 764 00e8 F801      		movw r30,r16
 765 00ea 0080      		ld r0,Z
 766 00ec 00C0      		rjmp 2f
 767               		1:
 768 00ee 220F      		lsl r18
 769 00f0 331F      		rol r19
 770               		2:
 771 00f2 0A94      		dec r0
 772 00f4 02F4      		brpl 1b
 773 00f6 822F      		mov r24,r18
 774 00f8 8095      		com r24
 775 00fa 8923      		and r24,r25
 776 00fc 82BB      		out 0x12,r24
 777 00fe 00C0      		rjmp .L33
 778               	.L32:
 254:main.c        **** 			}
 255:main.c        **** 			else		// PORT C
 256:main.c        **** 			{
 257:main.c        **** 				PORTC &= ~(1<<NOTES_tab[i]);
 779               		.loc 1 257 0
 780 0100 95B3      		in r25,0x15
 781 0102 9601      		movw r18,r12
 782 0104 F801      		movw r30,r16
 783 0106 0080      		ld r0,Z
 784 0108 00C0      		rjmp 2f
 785               		1:
 786 010a 220F      		lsl r18
 787 010c 331F      		rol r19
 788               		2:
 789 010e 0A94      		dec r0
 790 0110 02F4      		brpl 1b
 791 0112 822F      		mov r24,r18
 792 0114 8095      		com r24
 793 0116 8923      		and r24,r25
 794 0118 85BB      		out 0x15,r24
 795               	.L33:
 212:main.c        **** 		{
 796               		.loc 1 212 0 discriminator 2
 797 011a 2196      		adiw r28,1
 798               	.LVL49:
 799 011c 0E5F      		subi r16,-2
 800 011e 1F4F      		sbci r17,-1
 801 0120 F8E0      		ldi r31,8
 802 0122 6F0E      		add r6,r31
 803 0124 711C      		adc r7,__zero_reg__
 804 0126 CD30      		cpi r28,13
 805 0128 D105      		cpc r29,__zero_reg__
 806 012a 01F0      		breq .+2
 807 012c 00C0      		rjmp .L34
 808 012e 00C0      		rjmp .L35
 809               	.LBE2:
 810               		.cfi_endproc
 811               	.LFE12:
 813               	.global	pitch_bend
 814               		.section .bss
 817               	pitch_bend:
 818 0000 0000      		.zero	2
 819               	.global	adc_0_prev
 822               	adc_0_prev:
 823 0002 0000      		.zero	2
 824               	.global	adc_6
 827               	adc_6:
 828 0004 0000      		.zero	2
 829               	.global	adc_1
 832               	adc_1:
 833 0006 0000      		.zero	2
 834               	.global	adc_0
 837               	adc_0:
 838 0008 0000      		.zero	2
 839               	.global	adc_prev_read
 842               	adc_prev_read:
 843 000a 0000 0000 		.zero	16
 843      0000 0000 
 843      0000 0000 
 843      0000 0000 
 844               	.global	adc_read
 847               	adc_read:
 848 001a 0000 0000 		.zero	16
 848      0000 0000 
 848      0000 0000 
 848      0000 0000 
 849               	.global	PRESSED_BUTTON_tab
 852               	PRESSED_BUTTON_tab:
 853 002a 0000 0000 		.zero	104
 853      0000 0000 
 853      0000 0000 
 853      0000 0000 
 853      0000 0000 
 854               	.global	OCTAVES_tab
 855               		.data
 858               	OCTAVES_tab:
 859 0000 0400      		.word	4
 860 0002 0500      		.word	5
 861 0004 0600      		.word	6
 862 0006 0700      		.word	7
 863               	.global	NOTES_tab
 866               	NOTES_tab:
 867 0008 0000      		.word	0
 868 000a 0200      		.word	2
 869 000c 0300      		.word	3
 870 000e 0400      		.word	4
 871 0010 0500      		.word	5
 872 0012 0600      		.word	6
 873 0014 0700      		.word	7
 874 0016 0200      		.word	2
 875 0018 0300      		.word	3
 876 001a 0400      		.word	4
 877 001c 0500      		.word	5
 878 001e 0600      		.word	6
 879 0020 0700      		.word	7
 880               		.text
 881               	.Letext0:
 882               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc8sBLxz.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8sBLxz.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8sBLxz.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8sBLxz.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8sBLxz.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8sBLxz.s:12     .text:0000000000000000 TIM1_Init
     /tmp/cc8sBLxz.s:50     .text:000000000000001e USART_Init
     /tmp/cc8sBLxz.s:76     .text:000000000000002c uart_putchar
     /tmp/cc8sBLxz.s:97     .text:0000000000000034 uart_putstring
     /tmp/cc8sBLxz.s:140    .text:0000000000000050 uart_putint
     /tmp/cc8sBLxz.s:198    .text:000000000000008c ADC_Init
     /tmp/cc8sBLxz.s:220    .text:0000000000000098 ADC_read
     /tmp/cc8sBLxz.s:253    .text:00000000000000ae PORT_Init
     /tmp/cc8sBLxz.s:277    .text:00000000000000bc note_on
     /tmp/cc8sBLxz.s:323    .text:00000000000000e2 note_off
     /tmp/cc8sBLxz.s:369    .text:0000000000000108 CC_send_ADC
     /tmp/cc8sBLxz.s:842    .bss:000000000000000a adc_prev_read
     /tmp/cc8sBLxz.s:847    .bss:000000000000001a adc_read
     /tmp/cc8sBLxz.s:480    .text:0000000000000180 __vector_7
     /tmp/cc8sBLxz.s:596    .text.startup:0000000000000000 main
     /tmp/cc8sBLxz.s:866    .data:0000000000000008 NOTES_tab
     /tmp/cc8sBLxz.s:852    .bss:000000000000002a PRESSED_BUTTON_tab
     /tmp/cc8sBLxz.s:858    .data:0000000000000000 OCTAVES_tab
     /tmp/cc8sBLxz.s:817    .bss:0000000000000000 pitch_bend
     /tmp/cc8sBLxz.s:822    .bss:0000000000000002 adc_0_prev
     /tmp/cc8sBLxz.s:827    .bss:0000000000000004 adc_6
     /tmp/cc8sBLxz.s:832    .bss:0000000000000006 adc_1
     /tmp/cc8sBLxz.s:837    .bss:0000000000000008 adc_0

UNDEFINED SYMBOLS
itoa
__do_copy_data
__do_clear_bss
