   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	TIM1_Init
  12               	TIM1_Init:
  13               	.LFB0:
  14               		.file 1 "main.c"
   1:main.c        **** // device: 	AtMega 32
   2:main.c        **** // author:  Maciej Mielcarski
   3:main.c        **** 
   4:main.c        **** #define F_CPU 16000000UL
   5:main.c        **** #include <avr/io.h>
   6:main.c        **** #include <avr/interrupt.h>
   7:main.c        **** #define FOSC 16000000UL
   8:main.c        **** #define BAUD 9600
   9:main.c        **** #define MYUBRR FOSC/16/BAUD-1	// ubrr = 103	normal asynch. mode
  10:main.c        **** #include <util/setbaud.h>
  11:main.c        **** #define TIM1_PSC 1024		// TIMER 1 prescaler value
  12:main.c        **** #define TIM1_PER 100		// TIMER 1 desired period in miliseconds
  13:main.c        **** 
  14:main.c        **** 
  15:main.c        **** #define note1 PD0 
  16:main.c        **** #define note2 PD2 //
  17:main.c        **** #define note3 PD3 //
  18:main.c        **** #define note4 PD4 //
  19:main.c        **** #define note5 PD5 //
  20:main.c        **** #define note6 PD6 //
  21:main.c        **** #define note7 PD7 //
  22:main.c        **** #define note8 PC2 
  23:main.c        **** #define note9 PC3 
  24:main.c        **** #define note10 PC4 
  25:main.c        **** #define note11 PC5 
  26:main.c        **** #define note12 PC6 
  27:main.c        **** #define note13 PC7 
  28:main.c        **** 
  29:main.c        **** #define octave1 PB4 
  30:main.c        **** #define octave2 PB5 
  31:main.c        **** #define octave3 PB6 
  32:main.c        **** #define octave4 PB7 
  33:main.c        **** 
  34:main.c        **** int NOTES_tab[13] = {note1,note2,note3,note4,note5,note6,note7,note8,note9,note10,note11,note12,not
  35:main.c        **** int OCTAVES_tab[4] = {octave1,octave2,octave3,octave4};
  36:main.c        **** int PRESSED_BUTTON_tab[13][4]={0};
  37:main.c        **** 
  38:main.c        **** int adc_0 = 0, adc_1=0, adc_6=0;
  39:main.c        **** 
  40:main.c        **** // ------------------------- TIMER ----------------------------------------
  41:main.c        **** 
  42:main.c        **** void TIM1_Init()	// enable interrupts
  43:main.c        **** {
  15               		.loc 1 43 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  44:main.c        ****     OCR1A = (((F_CPU/1000) / TIM1_PSC) * TIM1_PER) - 1;	// counter size
  21               		.loc 1 44 0
  22 0000 8BED      		ldi r24,lo8(-37)
  23 0002 95E0      		ldi r25,lo8(5)
  24 0004 9BBD      		out 0x2a+1,r25
  25 0006 8ABD      		out 0x2a,r24
  45:main.c        ****     TCCR1B |= (1 << WGM12);							// Mode 4, CTC on OCR1A
  26               		.loc 1 45 0
  27 0008 8EB5      		in r24,0x2e
  28 000a 8860      		ori r24,lo8(8)
  29 000c 8EBD      		out 0x2e,r24
  46:main.c        ****     TIMSK |= (1 << OCIE1A);						// Set interrupt on compare match	
  30               		.loc 1 46 0
  31 000e 89B7      		in r24,0x39
  32 0010 8061      		ori r24,lo8(16)
  33 0012 89BF      		out 0x39,r24
  47:main.c        ****     TCCR1B |= (1 << CS12) | (1 << CS10);			// set prescaler to 1024 and start the timer
  34               		.loc 1 47 0
  35 0014 8EB5      		in r24,0x2e
  36 0016 8560      		ori r24,lo8(5)
  37 0018 8EBD      		out 0x2e,r24
  48:main.c        ****     sei();	
  38               		.loc 1 48 0
  39               	/* #APP */
  40               	 ;  48 "main.c" 1
  41 001a 7894      		sei
  42               	 ;  0 "" 2
  43               	/* #NOAPP */
  44 001c 0895      		ret
  45               		.cfi_endproc
  46               	.LFE0:
  48               	.global	USART_Init
  50               	USART_Init:
  51               	.LFB1:
  49:main.c        **** }
  50:main.c        **** 
  51:main.c        **** // ------------------------- USART ----------------------------------------
  52:main.c        **** 
  53:main.c        **** void USART_Init(unsigned int ubrr)		
  54:main.c        **** {
  52               		.loc 1 54 0
  53               		.cfi_startproc
  54               	.LVL0:
  55               	/* prologue: function */
  56               	/* frame size = 0 */
  57               	/* stack size = 0 */
  58               	.L__stack_usage = 0
  55:main.c        ****    UBRRH = (unsigned char)(ubrr>>8);	// set baud rate to 9600
  59               		.loc 1 55 0
  60 001e 90BD      		out 0x20,r25
  56:main.c        ****    UBRRL = (unsigned char)ubrr;		//
  61               		.loc 1 56 0
  62 0020 89B9      		out 0x9,r24
  57:main.c        ****    UCSRB = (1<<TXEN);		// Enable transmitter 
  63               		.loc 1 57 0
  64 0022 88E0      		ldi r24,lo8(8)
  65               	.LVL1:
  66 0024 8AB9      		out 0xa,r24
  58:main.c        ****    UCSRC = (1<<URSEL)|(1<<USBS)|(3<<UCSZ0);		// Set frame format: 8data, 2stop bit
  67               		.loc 1 58 0
  68 0026 8EE8      		ldi r24,lo8(-114)
  69 0028 80BD      		out 0x20,r24
  70 002a 0895      		ret
  71               		.cfi_endproc
  72               	.LFE1:
  74               	.global	uart_putchar
  76               	uart_putchar:
  77               	.LFB2:
  59:main.c        **** }
  60:main.c        **** 
  61:main.c        **** void uart_putchar(char c) 
  62:main.c        **** {
  78               		.loc 1 62 0
  79               		.cfi_startproc
  80               	/* prologue: function */
  81               	/* frame size = 0 */
  82               	/* stack size = 0 */
  83               	.L__stack_usage = 0
  84               	.LVL2:
  85               	.L4:
  63:main.c        **** 	while ( !(UCSRA & (1<<UDRE)) )	// Wait for empty transmit buffer 
  86               		.loc 1 63 0 discriminator 1
  87 002c 5D9B      		sbis 0xb,5
  88 002e 00C0      		rjmp .L4
  64:main.c        **** 	;
  65:main.c        ****     UDR = c;							// Put data into buffer, sends the data 
  89               		.loc 1 65 0
  90 0030 8CB9      		out 0xc,r24
  91 0032 0895      		ret
  92               		.cfi_endproc
  93               	.LFE2:
  95               	.global	uart_getchar
  97               	uart_getchar:
  98               	.LFB3:
  66:main.c        **** }
  67:main.c        **** 
  68:main.c        **** char uart_getchar(void) {
  99               		.loc 1 68 0
 100               		.cfi_startproc
 101               	/* prologue: function */
 102               	/* frame size = 0 */
 103               	/* stack size = 0 */
 104               	.L__stack_usage = 0
 105               	.L9:
  69:main.c        ****     loop_until_bit_is_set(UCSRA, RXC); 	// Wait until data exists
 106               		.loc 1 69 0 discriminator 1
 107 0034 5F9B      		sbis 0xb,7
 108 0036 00C0      		rjmp .L9
  70:main.c        ****     return UDR;
 109               		.loc 1 70 0
 110 0038 8CB1      		in r24,0xc
  71:main.c        **** }
 111               		.loc 1 71 0
 112 003a 0895      		ret
 113               		.cfi_endproc
 114               	.LFE3:
 116               	.global	uart_putstring
 118               	uart_putstring:
 119               	.LFB4:
  72:main.c        **** 
  73:main.c        **** void uart_putstring(char tab[])
  74:main.c        **** {
 120               		.loc 1 74 0
 121               		.cfi_startproc
 122               	.LVL3:
 123 003c CF93      		push r28
 124               	.LCFI0:
 125               		.cfi_def_cfa_offset 3
 126               		.cfi_offset 28, -2
 127 003e DF93      		push r29
 128               	.LCFI1:
 129               		.cfi_def_cfa_offset 4
 130               		.cfi_offset 29, -3
 131               	/* prologue: function */
 132               	/* frame size = 0 */
 133               	/* stack size = 2 */
 134               	.L__stack_usage = 2
 135               	.L12:
  75:main.c        **** 	int i =0;
  76:main.c        **** 	while (( UCSRA & (1<<UDRE))  == 0){};
 136               		.loc 1 76 0 discriminator 1
 137 0040 5D9B      		sbis 0xb,5
 138 0042 00C0      		rjmp .L12
 139 0044 EC01      		movw r28,r24
 140               	.LVL4:
 141               	.L13:
  77:main.c        ****         while (tab[i] != 0x00)
 142               		.loc 1 77 0
 143 0046 8991      		ld r24,Y+
 144 0048 8823      		tst r24
 145 004a 01F0      		breq .L17
  78:main.c        **** 		{ 
  79:main.c        ****             uart_putchar(tab[i]);
 146               		.loc 1 79 0
 147 004c 0E94 0000 		call uart_putchar
 148               	.LVL5:
 149 0050 00C0      		rjmp .L13
 150               	.L17:
 151               	/* epilogue start */
  80:main.c        **** 			i++; 
  81:main.c        ****         }
  82:main.c        **** }
 152               		.loc 1 82 0
 153 0052 DF91      		pop r29
 154 0054 CF91      		pop r28
 155 0056 0895      		ret
 156               		.cfi_endproc
 157               	.LFE4:
 159               	.global	uart_putint
 161               	uart_putint:
 162               	.LFB5:
  83:main.c        **** 
  84:main.c        **** void uart_putint(int value)
  85:main.c        **** {
 163               		.loc 1 85 0
 164               		.cfi_startproc
 165               	.LVL6:
 166 0058 CF93      		push r28
 167               	.LCFI2:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170 005a DF93      		push r29
 171               	.LCFI3:
 172               		.cfi_def_cfa_offset 4
 173               		.cfi_offset 29, -3
 174 005c CDB7      		in r28,__SP_L__
 175 005e DEB7      		in r29,__SP_H__
 176               	.LCFI4:
 177               		.cfi_def_cfa_register 28
 178 0060 6097      		sbiw r28,16
 179               	.LCFI5:
 180               		.cfi_def_cfa_offset 20
 181 0062 0FB6      		in __tmp_reg__,__SREG__
 182 0064 F894      		cli
 183 0066 DEBF      		out __SP_H__,r29
 184 0068 0FBE      		out __SREG__,__tmp_reg__
 185 006a CDBF      		out __SP_L__,r28
 186               	/* prologue: function */
 187               	/* frame size = 16 */
 188               	/* stack size = 18 */
 189               	.L__stack_usage = 18
  86:main.c        **** 	char tab[16];
  87:main.c        **** 	itoa(value,tab,10);
 190               		.loc 1 87 0
 191 006c 4AE0      		ldi r20,lo8(10)
 192 006e 50E0      		ldi r21,0
 193 0070 BE01      		movw r22,r28
 194 0072 6F5F      		subi r22,-1
 195 0074 7F4F      		sbci r23,-1
 196 0076 0E94 0000 		call itoa
 197               	.LVL7:
  88:main.c        **** 	uart_putstring(tab);
 198               		.loc 1 88 0
 199 007a CE01      		movw r24,r28
 200 007c 0196      		adiw r24,1
 201 007e 0E94 0000 		call uart_putstring
 202               	.LVL8:
 203               	/* epilogue start */
  89:main.c        **** }
 204               		.loc 1 89 0
 205 0082 6096      		adiw r28,16
 206 0084 0FB6      		in __tmp_reg__,__SREG__
 207 0086 F894      		cli
 208 0088 DEBF      		out __SP_H__,r29
 209 008a 0FBE      		out __SREG__,__tmp_reg__
 210 008c CDBF      		out __SP_L__,r28
 211 008e DF91      		pop r29
 212 0090 CF91      		pop r28
 213 0092 0895      		ret
 214               		.cfi_endproc
 215               	.LFE5:
 217               	.global	ADC_Init
 219               	ADC_Init:
 220               	.LFB6:
  90:main.c        **** 
  91:main.c        **** // ------------------------- ADC ----------------------------------------
  92:main.c        **** 
  93:main.c        **** void ADC_Init()
  94:main.c        **** {
 221               		.loc 1 94 0
 222               		.cfi_startproc
 223               	/* prologue: function */
 224               	/* frame size = 0 */
 225               	/* stack size = 0 */
 226               	.L__stack_usage = 0
  95:main.c        **** 	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0); // Set ADC prescaler to 128 - 125KHz sample 
 227               		.loc 1 95 0
 228 0094 86B1      		in r24,0x6
 229 0096 8760      		ori r24,lo8(7)
 230 0098 86B9      		out 0x6,r24
  96:main.c        **** 	ADMUX |= (1 << REFS0); 	// Set ADC reference to AVCC
 231               		.loc 1 96 0
 232 009a 3E9A      		sbi 0x7,6
  97:main.c        **** 	
  98:main.c        **** 	ADCSRA |= (1 << ADEN);  // Enable ADC
 233               		.loc 1 98 0
 234 009c 379A      		sbi 0x6,7
 235 009e 0895      		ret
 236               		.cfi_endproc
 237               	.LFE6:
 239               	.global	ADC_read
 241               	ADC_read:
 242               	.LFB7:
  99:main.c        **** 	//ADCSRA |= (1 << ADSC);  // Start A2D Conversions
 100:main.c        **** 	//ADCSRA |= (1 << ADATE);	// for free running mode
 101:main.c        **** }
 102:main.c        **** 
 103:main.c        **** uint16_t ADC_read(uint8_t channel)		
 104:main.c        **** {
 243               		.loc 1 104 0
 244               		.cfi_startproc
 245               	.LVL9:
 246               	/* prologue: function */
 247               	/* frame size = 0 */
 248               	/* stack size = 0 */
 249               	.L__stack_usage = 0
 105:main.c        **** 	channel &= 0x07;					// AND operation with 7 (will keep channel between 0-7) 
 106:main.c        **** 	ADMUX = (ADMUX & 0xF8) | channel;	// clears 3 first bits before OR
 250               		.loc 1 106 0
 251 00a0 97B1      		in r25,0x7
 252 00a2 987F      		andi r25,lo8(-8)
 253 00a4 8770      		andi r24,lo8(7)
 254               	.LVL10:
 255 00a6 892B      		or r24,r25
 256               	.LVL11:
 257 00a8 87B9      		out 0x7,r24
 107:main.c        **** 
 108:main.c        **** 	ADCSRA |= (1 << ADSC);				// start single convesrion
 258               		.loc 1 108 0
 259 00aa 369A      		sbi 0x6,6
 260               	.L21:
 109:main.c        **** 	while(ADCSRA & (1 << ADSC));		// wait for conversion to complete
 261               		.loc 1 109 0 discriminator 1
 262 00ac 3699      		sbic 0x6,6
 263 00ae 00C0      		rjmp .L21
 110:main.c        **** 	return ADCW;
 264               		.loc 1 110 0
 265 00b0 84B1      		in r24,0x4
 266 00b2 95B1      		in r25,0x4+1
 111:main.c        **** }
 267               		.loc 1 111 0
 268 00b4 0895      		ret
 269               		.cfi_endproc
 270               	.LFE7:
 272               	.global	PORT_Init
 274               	PORT_Init:
 275               	.LFB8:
 112:main.c        **** 
 113:main.c        **** // ------------------------- OTHER ----------------------------------------
 114:main.c        **** 
 115:main.c        **** 
 116:main.c        **** 
 117:main.c        **** void PORT_Init()
 118:main.c        **** {
 276               		.loc 1 118 0
 277               		.cfi_startproc
 278               	/* prologue: function */
 279               	/* frame size = 0 */
 280               	/* stack size = 0 */
 281               	.L__stack_usage = 0
 119:main.c        **** 	MCUCSR = (1<<JTD);			//disabling JTAG
 282               		.loc 1 119 0
 283 00b6 80E8      		ldi r24,lo8(-128)
 284 00b8 84BF      		out 0x34,r24
 120:main.c        **** 	MCUCSR = (1<<JTD);			//
 285               		.loc 1 120 0
 286 00ba 84BF      		out 0x34,r24
 121:main.c        **** 	DDRD = 0xFF;
 287               		.loc 1 121 0
 288 00bc 8FEF      		ldi r24,lo8(-1)
 289 00be 81BB      		out 0x11,r24
 122:main.c        **** 	DDRC = 0xFF;
 290               		.loc 1 122 0
 291 00c0 84BB      		out 0x14,r24
 292 00c2 0895      		ret
 293               		.cfi_endproc
 294               	.LFE8:
 296               		.section	.rodata.str1.1,"aMS",@progbits,1
 297               	.LC0:
 298 0000 0A6B 6579 		.string	"\nkey:"
 298      3A00 
 299               	.LC1:
 300 0006 0A6F 6374 		.string	"\noct"
 300      00
 301               		.text
 302               	.global	note_on
 304               	note_on:
 305               	.LFB9:
 123:main.c        **** }
 124:main.c        **** 
 125:main.c        **** void note_on(int key, int oct)
 126:main.c        **** {
 306               		.loc 1 126 0
 307               		.cfi_startproc
 308               	.LVL12:
 309 00c4 0F93      		push r16
 310               	.LCFI6:
 311               		.cfi_def_cfa_offset 3
 312               		.cfi_offset 16, -2
 313 00c6 1F93      		push r17
 314               	.LCFI7:
 315               		.cfi_def_cfa_offset 4
 316               		.cfi_offset 17, -3
 317 00c8 CF93      		push r28
 318               	.LCFI8:
 319               		.cfi_def_cfa_offset 5
 320               		.cfi_offset 28, -4
 321 00ca DF93      		push r29
 322               	.LCFI9:
 323               		.cfi_def_cfa_offset 6
 324               		.cfi_offset 29, -5
 325               	/* prologue: function */
 326               	/* frame size = 0 */
 327               	/* stack size = 4 */
 328               	.L__stack_usage = 4
 329 00cc 8C01      		movw r16,r24
 330 00ce EB01      		movw r28,r22
 127:main.c        **** 	//uart_putchar('N');
 128:main.c        **** 	//uart_putchar('-');
 129:main.c        **** 	uart_putstring("\nkey:");
 331               		.loc 1 129 0
 332 00d0 80E0      		ldi r24,lo8(.LC0)
 333 00d2 90E0      		ldi r25,hi8(.LC0)
 334               	.LVL13:
 335 00d4 0E94 0000 		call uart_putstring
 336               	.LVL14:
 130:main.c        **** 	uart_putint(key);
 337               		.loc 1 130 0
 338 00d8 C801      		movw r24,r16
 339 00da 0E94 0000 		call uart_putint
 340               	.LVL15:
 131:main.c        **** 	//uart_putchar('O');
 132:main.c        **** 	//uart_putchar('-');
 133:main.c        **** 	uart_putstring("\noct");
 341               		.loc 1 133 0
 342 00de 80E0      		ldi r24,lo8(.LC1)
 343 00e0 90E0      		ldi r25,hi8(.LC1)
 344 00e2 0E94 0000 		call uart_putstring
 345               	.LVL16:
 134:main.c        **** 	uart_putint(oct);
 346               		.loc 1 134 0
 347 00e6 CE01      		movw r24,r28
 348               	/* epilogue start */
 135:main.c        **** }
 349               		.loc 1 135 0
 350 00e8 DF91      		pop r29
 351 00ea CF91      		pop r28
 352               	.LVL17:
 353 00ec 1F91      		pop r17
 354 00ee 0F91      		pop r16
 355               	.LVL18:
 134:main.c        **** 	uart_putint(oct);
 356               		.loc 1 134 0
 357 00f0 0C94 0000 		jmp uart_putint
 358               	.LVL19:
 359               		.cfi_endproc
 360               	.LFE9:
 362               	.global	note_off
 364               	note_off:
 365               	.LFB10:
 136:main.c        **** 
 137:main.c        **** void note_off(int key, int oct)
 138:main.c        **** {
 366               		.loc 1 138 0
 367               		.cfi_startproc
 368               	.LVL20:
 369               	/* prologue: function */
 370               	/* frame size = 0 */
 371               	/* stack size = 0 */
 372               	.L__stack_usage = 0
 373 00f4 0895      		ret
 374               		.cfi_endproc
 375               	.LFE10:
 377               		.section	.rodata.str1.1
 378               	.LC2:
 379 000b 0A41 4443 		.string	"\nADC1:"
 379      313A 00
 380               		.text
 381               	.global	__vector_7
 383               	__vector_7:
 384               	.LFB11:
 139:main.c        **** 
 140:main.c        **** }
 141:main.c        **** 
 142:main.c        **** ISR(TIMER1_COMPA_vect)	// timer1 overflow interrupt
 143:main.c        **** {
 385               		.loc 1 143 0
 386               		.cfi_startproc
 387               		.loc 1 143 0
 388 00f6 1F92      		push r1
 389               	.LCFI10:
 390               		.cfi_def_cfa_offset 3
 391               		.cfi_offset 1, -2
 392 00f8 0F92      		push r0
 393               	.LCFI11:
 394               		.cfi_def_cfa_offset 4
 395               		.cfi_offset 0, -3
 396 00fa 0FB6      		in r0,__SREG__
 397 00fc 0F92      		push r0
 398 00fe 1124      		clr __zero_reg__
 399 0100 2F93      		push r18
 400               	.LCFI12:
 401               		.cfi_def_cfa_offset 5
 402               		.cfi_offset 18, -4
 403 0102 3F93      		push r19
 404               	.LCFI13:
 405               		.cfi_def_cfa_offset 6
 406               		.cfi_offset 19, -5
 407 0104 4F93      		push r20
 408               	.LCFI14:
 409               		.cfi_def_cfa_offset 7
 410               		.cfi_offset 20, -6
 411 0106 5F93      		push r21
 412               	.LCFI15:
 413               		.cfi_def_cfa_offset 8
 414               		.cfi_offset 21, -7
 415 0108 6F93      		push r22
 416               	.LCFI16:
 417               		.cfi_def_cfa_offset 9
 418               		.cfi_offset 22, -8
 419 010a 7F93      		push r23
 420               	.LCFI17:
 421               		.cfi_def_cfa_offset 10
 422               		.cfi_offset 23, -9
 423 010c 8F93      		push r24
 424               	.LCFI18:
 425               		.cfi_def_cfa_offset 11
 426               		.cfi_offset 24, -10
 427 010e 9F93      		push r25
 428               	.LCFI19:
 429               		.cfi_def_cfa_offset 12
 430               		.cfi_offset 25, -11
 431 0110 AF93      		push r26
 432               	.LCFI20:
 433               		.cfi_def_cfa_offset 13
 434               		.cfi_offset 26, -12
 435 0112 BF93      		push r27
 436               	.LCFI21:
 437               		.cfi_def_cfa_offset 14
 438               		.cfi_offset 27, -13
 439 0114 EF93      		push r30
 440               	.LCFI22:
 441               		.cfi_def_cfa_offset 15
 442               		.cfi_offset 30, -14
 443 0116 FF93      		push r31
 444               	.LCFI23:
 445               		.cfi_def_cfa_offset 16
 446               		.cfi_offset 31, -15
 447               	/* prologue: Signal */
 448               	/* frame size = 0 */
 449               	/* stack size = 15 */
 450               	.L__stack_usage = 15
 144:main.c        **** 	// ------- ADC test -------
 145:main.c        **** 	// adc_0 = ADC_read(0);
 146:main.c        **** 	// uart_putstring("\nADC0:");
 147:main.c        **** 	// uart_putint(adc_0);
 148:main.c        **** 	// //uart_putchar('K');
 149:main.c        **** 
 150:main.c        **** 	adc_1 = ADC_read(1);
 451               		.loc 1 150 0
 452 0118 81E0      		ldi r24,lo8(1)
 453 011a 0E94 0000 		call ADC_read
 454               	.LVL21:
 455 011e 9093 0000 		sts adc_1+1,r25
 456 0122 8093 0000 		sts adc_1,r24
 151:main.c        **** 	uart_putstring("\nADC1:");
 457               		.loc 1 151 0
 458 0126 80E0      		ldi r24,lo8(.LC2)
 459 0128 90E0      		ldi r25,hi8(.LC2)
 460 012a 0E94 0000 		call uart_putstring
 461               	.LVL22:
 152:main.c        **** 	uart_putint(adc_1);
 462               		.loc 1 152 0
 463 012e 8091 0000 		lds r24,adc_1
 464 0132 9091 0000 		lds r25,adc_1+1
 465 0136 0E94 0000 		call uart_putint
 466               	.LVL23:
 467               	/* epilogue start */
 153:main.c        **** 
 154:main.c        **** 	// adc_6 = ADC_read(6);
 155:main.c        **** 	// uart_putstring("\nADC6:");
 156:main.c        **** 	// uart_putint(adc_6);
 157:main.c        **** }
 468               		.loc 1 157 0
 469 013a FF91      		pop r31
 470 013c EF91      		pop r30
 471 013e BF91      		pop r27
 472 0140 AF91      		pop r26
 473 0142 9F91      		pop r25
 474 0144 8F91      		pop r24
 475 0146 7F91      		pop r23
 476 0148 6F91      		pop r22
 477 014a 5F91      		pop r21
 478 014c 4F91      		pop r20
 479 014e 3F91      		pop r19
 480 0150 2F91      		pop r18
 481 0152 0F90      		pop r0
 482 0154 0FBE      		out __SREG__,r0
 483 0156 0F90      		pop r0
 484 0158 1F90      		pop r1
 485 015a 1895      		reti
 486               		.cfi_endproc
 487               	.LFE11:
 489               		.section	.text.startup,"ax",@progbits
 490               	.global	main
 492               	main:
 493               	.LFB12:
 158:main.c        **** 
 159:main.c        **** // ------------------------- MAIN ----------------------------------------
 160:main.c        **** 
 161:main.c        **** int main(void)
 162:main.c        **** {
 494               		.loc 1 162 0
 495               		.cfi_startproc
 496               	/* prologue: function */
 497               	/* frame size = 0 */
 498               	/* stack size = 0 */
 499               	.L__stack_usage = 0
 163:main.c        **** 	USART_Init(MYUBRR);
 500               		.loc 1 163 0
 501 0000 87E6      		ldi r24,lo8(103)
 502 0002 90E0      		ldi r25,0
 503 0004 0E94 0000 		call USART_Init
 504               	.LVL24:
 164:main.c        **** 	PORT_Init();
 505               		.loc 1 164 0
 506 0008 0E94 0000 		call PORT_Init
 507               	.LVL25:
 165:main.c        **** 	ADC_Init();
 508               		.loc 1 165 0
 509 000c 0E94 0000 		call ADC_Init
 510               	.LVL26:
 166:main.c        **** 	TIM1_Init();
 511               		.loc 1 166 0
 512 0010 0E94 0000 		call TIM1_Init
 513               	.LVL27:
 514               	.L28:
 515 0014 00C0      		rjmp .L28
 516               		.cfi_endproc
 517               	.LFE12:
 519               	.global	adc_6
 520               		.section .bss
 523               	adc_6:
 524 0000 0000      		.zero	2
 525               	.global	adc_1
 528               	adc_1:
 529 0002 0000      		.zero	2
 530               	.global	adc_0
 533               	adc_0:
 534 0004 0000      		.zero	2
 535               	.global	PRESSED_BUTTON_tab
 538               	PRESSED_BUTTON_tab:
 539 0006 0000 0000 		.zero	104
 539      0000 0000 
 539      0000 0000 
 539      0000 0000 
 539      0000 0000 
 540               	.global	OCTAVES_tab
 541               		.data
 544               	OCTAVES_tab:
 545 0000 0400      		.word	4
 546 0002 0500      		.word	5
 547 0004 0600      		.word	6
 548 0006 0700      		.word	7
 549               	.global	NOTES_tab
 552               	NOTES_tab:
 553 0008 0000      		.word	0
 554 000a 0200      		.word	2
 555 000c 0300      		.word	3
 556 000e 0400      		.word	4
 557 0010 0500      		.word	5
 558 0012 0600      		.word	6
 559 0014 0700      		.word	7
 560 0016 0200      		.word	2
 561 0018 0300      		.word	3
 562 001a 0400      		.word	4
 563 001c 0500      		.word	5
 564 001e 0600      		.word	6
 565 0020 0700      		.word	7
 566               		.text
 567               	.Letext0:
 568               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccqafjq1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqafjq1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqafjq1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqafjq1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqafjq1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqafjq1.s:12     .text:0000000000000000 TIM1_Init
     /tmp/ccqafjq1.s:50     .text:000000000000001e USART_Init
     /tmp/ccqafjq1.s:76     .text:000000000000002c uart_putchar
     /tmp/ccqafjq1.s:97     .text:0000000000000034 uart_getchar
     /tmp/ccqafjq1.s:118    .text:000000000000003c uart_putstring
     /tmp/ccqafjq1.s:161    .text:0000000000000058 uart_putint
     /tmp/ccqafjq1.s:219    .text:0000000000000094 ADC_Init
     /tmp/ccqafjq1.s:241    .text:00000000000000a0 ADC_read
     /tmp/ccqafjq1.s:274    .text:00000000000000b6 PORT_Init
     /tmp/ccqafjq1.s:304    .text:00000000000000c4 note_on
     /tmp/ccqafjq1.s:364    .text:00000000000000f4 note_off
     /tmp/ccqafjq1.s:383    .text:00000000000000f6 __vector_7
     /tmp/ccqafjq1.s:528    .bss:0000000000000002 adc_1
     /tmp/ccqafjq1.s:492    .text.startup:0000000000000000 main
     /tmp/ccqafjq1.s:523    .bss:0000000000000000 adc_6
     /tmp/ccqafjq1.s:533    .bss:0000000000000004 adc_0
     /tmp/ccqafjq1.s:538    .bss:0000000000000006 PRESSED_BUTTON_tab
     /tmp/ccqafjq1.s:544    .data:0000000000000000 OCTAVES_tab
     /tmp/ccqafjq1.s:552    .data:0000000000000008 NOTES_tab

UNDEFINED SYMBOLS
itoa
__do_copy_data
__do_clear_bss
